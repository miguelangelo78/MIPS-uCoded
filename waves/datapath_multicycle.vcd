$date
	Fri Jun 24 00:57:02 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module datapath_multicycle $end
$var wire 32 ! instr_in [31:0] $end
$var wire 32 " mdr_data_in [31:0] $end
$var wire 32 # mem_data_in [31:0] $end
$var wire 1 $ pc_wr $end
$var wire 1 % zero $end
$var wire 5 & writereg [4:0] $end
$var wire 32 ' writedata [31:0] $end
$var wire 32 ( result [31:0] $end
$var wire 1 ) regwrite $end
$var wire 1 * regdst $end
$var wire 5 + readreg2 [4:0] $end
$var wire 5 , readreg1 [4:0] $end
$var wire 1 - pcwritecond $end
$var wire 1 . pcwrite $end
$var wire 2 / pcsource [1:0] $end
$var wire 32 0 outB [31:0] $end
$var wire 32 1 outA [31:0] $end
$var wire 32 2 opB [31:0] $end
$var wire 32 3 opA [31:0] $end
$var wire 1 4 microcode_done $end
$var wire 1 5 memwrite $end
$var wire 1 6 memtoreg $end
$var wire 1 7 memread $end
$var wire 32 8 mem_data_out [31:0] $end
$var wire 32 9 mem_addr [31:0] $end
$var wire 32 : mdr_data_out [31:0] $end
$var wire 1 ; irwrite $end
$var wire 32 < ip_next [31:0] $end
$var wire 32 = ip [31:0] $end
$var wire 1 > iord $end
$var wire 32 ? instr_out [31:0] $end
$var wire 4 @ func [3:0] $end
$var wire 33 A ctrl [32:0] $end
$var wire 2 B alusrcb [1:0] $end
$var wire 1 C alusrca $end
$var wire 32 D aluout [31:0] $end
$var wire 2 E aluop [1:0] $end
$var reg 1 F clk $end
$var reg 1 G en_clk $end
$var reg 1 H microcode_restart $end
$scope module alu $end
$var wire 1 F clk $end
$var wire 4 I func [3:0] $end
$var wire 32 J opA [31:0] $end
$var wire 32 K opB [31:0] $end
$var wire 1 % zero $end
$var wire 32 L result [31:0] $end
$var reg 32 M aluout [31:0] $end
$upscope $end
$scope module instructionReg $end
$var wire 32 N instr_in [31:0] $end
$var wire 1 ; irwrite $end
$var reg 32 O instr_out [31:0] $end
$upscope $end
$scope module mdr $end
$var wire 1 F clk $end
$var wire 32 P data_in [31:0] $end
$var reg 32 Q data_out [31:0] $end
$upscope $end
$scope module memory $end
$var wire 32 R address [31:0] $end
$var wire 32 S data_in [31:0] $end
$var wire 1 7 memread $end
$var wire 1 5 memwrite $end
$var wire 32 T data_out [31:0] $end
$upscope $end
$scope module microcode $end
$var wire 1 F clk $end
$var wire 6 U opcode [5:0] $end
$var wire 1 H sos $end
$var wire 1 4 eos $end
$var reg 8 V code_ip [7:0] $end
$var reg 33 W ctrl [32:0] $end
$var reg 1 X flag_jmp $end
$var reg 8 Y flag_jmp_addr [7:0] $end
$var reg 32 Z func_fmt [31:0] $end
$var reg 2 [ instruction_type [1:0] $end
$var reg 1 \ microunit_init $end
$var reg 1 ] microunit_running $end
$var reg 8 ^ stack_ptr [7:0] $end
$var reg 1 _ zero $end
$var integer 32 ` int_segment_counter [31:0] $end
$var integer 32 a microinstr_ctr [31:0] $end
$var integer 32 b segment_counter [31:0] $end
$scope task check_microcode_running $end
$upscope $end
$scope task exec_microinstruction $end
$var reg 8 c address [7:0] $end
$upscope $end
$scope task microinstr $end
$var reg 32 d control [31:0] $end
$var reg 32 e func [31:0] $end
$var reg 2 f seg_type [1:0] $end
$var integer 32 g is_eos [31:0] $end
$var integer 32 h is_sos [31:0] $end
$upscope $end
$scope task microinstr_finish $end
$upscope $end
$scope task pop_stack $end
$upscope $end
$scope task push_stack $end
$var reg 8 i address [7:0] $end
$upscope $end
$scope task schedule_jmp $end
$var reg 8 j new_addr [7:0] $end
$upscope $end
$upscope $end
$scope module pc $end
$var wire 32 k ip_next [31:0] $end
$var wire 1 $ pc_wr $end
$var reg 32 l ip [31:0] $end
$upscope $end
$scope module registers $end
$var wire 1 F clk $end
$var wire 5 m readreg1 [4:0] $end
$var wire 5 n readreg2 [4:0] $end
$var wire 1 ) regwr $end
$var wire 32 o writedata [31:0] $end
$var wire 5 p writereg [4:0] $end
$var reg 32 q outA [31:0] $end
$var reg 32 r outB [31:0] $end
$scope begin $unm_blk_27 $end
$var integer 32 s i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 s
b0 r
b0 q
b0 p
b0 o
b0 n
b0 m
b0 l
b0 k
bx j
bx i
b1 h
b1 g
b0 f
b0 e
b1001010 d
bx c
b100000000 b
b100000000 a
b100000000 `
0_
b0 ^
1]
0\
b0 [
b0 Z
b11111111 Y
0X
b0 W
b0 V
b0 U
bz T
b0 S
b0 R
b0 Q
bz P
b0 O
bz N
b0 M
b0 L
b0 K
b0 J
b10 I
0H
0G
0F
b0 E
b0 D
0C
b0 B
b0 A
b10 @
b0 ?
0>
b0 =
b0 <
0;
b0 :
b0 9
bz 8
07
06
05
04
b0 3
b0 2
b0 1
b0 0
b0 /
0.
0-
b0 ,
b0 +
0*
0)
b0 (
b0 '
b0 &
1%
0$
b0 #
bz "
bz !
$end
#1
1$
1-
b1 A
b1 W
b1 ^
b1 i
1X
b100 Y
b100 j
b100000000000000000000000000001 Z
b0 c
1\
bz :
bz Q
1H
1G
1F
#2
0H
0F
#3
b10 ^
b101 i
b10 Y
b10 j
b100000000000000000000000000000 Z
b1 [
b100 c
1X
b100 V
1F
#4
0F
#5
b11 ^
b11 i
b110 Y
b110 j
b100000000000000000000000000010 Z
b10 c
1X
b10 V
1F
#6
0F
#7
14
b100000000000000000000000000000001 A
b100000000000000000000000000000001 W
b0 Z
b110 c
0X
b110 V
1F
#8
0F
#9
1X
b11 Y
b11 j
b10 ^
1F
#10
0F
#11
b11 c
0X
b11 V
1F
#12
0F
#13
1X
b101 Y
b101 j
b1 ^
1F
#14
0F
#15
b101 c
0X
b101 V
1F
#16
0F
#17
1X
b1 Y
b1 j
b0 ^
1F
#18
0F
#19
b0 [
b1 c
0X
b1 V
1F
#20
0F
#21
1F
#22
0F
#23
1F
#24
0F
#25
1F
#26
0F
#27
1F
#28
0F
#29
1F
#30
0F
#31
1F
#32
0F
#33
1F
#34
0F
#35
1F
#36
0F
#37
1F
#38
0F
#39
1F
#40
0F
#41
1F
#42
0F
#43
1F
#44
0F
#45
1F
#46
0F
#47
1F
#48
0F
#49
1F
#50
0F
#51
1F
