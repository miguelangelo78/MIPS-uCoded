$date
	Thu Jun 23 18:21:59 2016
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module datapath $end
$var wire 32 ! address [31:0] $end
$var wire 32 " data_writedata [31:0] $end
$var wire 1 # eip_inc $end
$var wire 32 $ opA [31:0] $end
$var wire 1 % zero $end
$var wire 5 & writereg [4:0] $end
$var wire 32 ' result [31:0] $end
$var wire 1 ( regwrite $end
$var wire 32 ) regout2 [31:0] $end
$var wire 32 * regout1 [31:0] $end
$var wire 1 + regdst $end
$var wire 5 , readreg2 [4:0] $end
$var wire 5 - readreg1 [4:0] $end
$var wire 32 . readdata [31:0] $end
$var wire 32 / prog_writedata [31:0] $end
$var wire 32 0 opB [31:0] $end
$var wire 1 1 microcode_done $end
$var wire 1 2 memwrite $end
$var wire 1 3 memtoreg $end
$var wire 1 4 memread $end
$var wire 1 5 jump $end
$var wire 32 6 instruction [31:0] $end
$var wire 4 7 func [3:0] $end
$var wire 32 8 eip_next [31:0] $end
$var wire 33 9 ctrl [32:0] $end
$var wire 1 : branch $end
$var wire 1 ; alusrc $end
$var wire 2 < aluop [1:0] $end
$var reg 1 = clk $end
$var reg 32 > eip [31:0] $end
$var reg 1 ? en_clk $end
$var reg 1 @ microcode_restart $end
$scope module alu $end
$var wire 4 A func [3:0] $end
$var wire 32 B opA [31:0] $end
$var wire 32 C opB [31:0] $end
$var wire 1 % zero $end
$var wire 32 D result [31:0] $end
$upscope $end
$scope module datamem $end
$var wire 32 E address [31:0] $end
$var wire 1 4 mrd $end
$var wire 1 2 mwr $end
$var wire 32 F writedata [31:0] $end
$var wire 32 G readdata [31:0] $end
$scope begin $unm_blk_13 $end
$var integer 32 H i [31:0] $end
$upscope $end
$upscope $end
$scope module microcode $end
$var wire 1 = clk $end
$var wire 6 I opcode [5:0] $end
$var wire 1 @ sos $end
$var wire 1 1 eos $end
$var reg 8 J code_ip [7:0] $end
$var reg 33 K ctrl [32:0] $end
$var reg 1 L microunit_init $end
$var reg 1 M microunit_running $end
$var integer 32 N microinstr_ctr [31:0] $end
$var integer 32 O segment_counter [31:0] $end
$scope task check_microcode_running $end
$upscope $end
$scope task microinstr $end
$var reg 32 P control [31:0] $end
$var integer 32 Q is_eos [31:0] $end
$var integer 32 R is_sos [31:0] $end
$upscope $end
$scope task microinstr_finish $end
$upscope $end
$upscope $end
$scope module progmem $end
$var wire 32 S address [31:0] $end
$var wire 32 T instruction [31:0] $end
$upscope $end
$scope module registers $end
$var wire 5 U readreg1 [4:0] $end
$var wire 5 V readreg2 [4:0] $end
$var wire 32 W regout1 [31:0] $end
$var wire 32 X regout2 [31:0] $end
$var wire 1 ( regwr $end
$var wire 32 Y writedata [31:0] $end
$var wire 5 Z writereg [4:0] $end
$scope begin $unm_blk_14 $end
$var integer 32 [ i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100000 [
b0 Z
b0 Y
b0 X
b0 W
b0 V
b0 U
b0 T
b0 S
b1 R
b1 Q
b110000000 P
b100000000 O
b100000000 N
1M
0L
b0 K
b0 J
b0 I
b100000000 H
bz G
b0 F
b0 E
b0 D
b0 C
b0 B
b10 A
0@
0?
b0 >
0=
b0 <
0;
0:
b0 9
b1 8
b10 7
b0 6
05
04
03
02
01
b0 0
b0 /
bz .
b0 -
b0 ,
0+
b0 *
b0 )
0(
b0 '
b0 &
1%
b0 $
0#
b0 "
b0 !
$end
#1
b1 I
b10 8
b100000000000000000000000000 6
b100000000000000000000000000 T
b1 >
b1 S
0%
b10101100 !
b10101100 E
b10101100 '
b10101100 D
b10101100 $
b10101100 B
b10101100 *
b10101100 W
b10101100 "
b10101100 F
b10101100 )
b10101100 X
b10101100 /
b10101100 Y
b10101100 .
b10101100 G
1#
11
1(
1;
13
14
b100000000000000000000001100011000 9
b100000000000000000000001100011000 K
1L
1?
1@
1=
#2
0@
0=
#3
b0 I
1@
b11 8
b0 6
b0 T
b10 >
b10 S
1=
#4
0@
0=
#5
bz .
bz G
0(
12
03
04
b100000000000000000000000110000000 9
b100000000000000000000000110000000 K
b1 J
b1 I
1@
b100 8
b100000000000000000000000000 6
b100000000000000000000000000 T
b11 >
b11 S
1=
#6
0@
0=
#7
b10101100 .
b10101100 G
1(
02
13
14
b100000000000000000000001100011000 9
b100000000000000000000001100011000 K
b0 J
b0 I
1@
b101 8
b0 6
b0 T
b100 >
b100 S
1=
#8
0@
0=
#9
0M
b111111 I
1@
b110 8
b11111100000000000000000000000000 6
b11111100000000000000000000000000 T
b101 >
b101 S
1=
#10
0@
0=
#11
x%
bx /
bx Y
bx .
bx G
bx !
bx E
bx '
bx D
b0xxxxxxxxxxxxxxxx 0
b0xxxxxxxxxxxxxxxx C
bx &
bx Z
xM
bx "
bx F
bx )
bx X
bx ,
bx V
bx $
bx B
bx *
bx W
bx -
bx U
bx I
1@
b111 8
bx 6
bx T
b110 >
b110 S
1=
#12
0@
0=
#13
1@
b1000 8
b111 >
b111 S
1=
#14
0@
0=
#15
1@
b1001 8
b1000 >
b1000 S
1=
#16
0@
0=
#17
1@
b1010 8
b1001 >
b1001 S
1=
#18
0@
0=
#19
1@
b1011 8
b1010 >
b1010 S
1=
#20
0@
0=
#21
1@
b1100 8
b1011 >
b1011 S
1=
#22
0@
0=
#23
1@
b1101 8
b1100 >
b1100 S
1=
#24
0@
0=
#25
1@
b1110 8
b1101 >
b1101 S
1=
#26
0@
0=
#27
1@
b1111 8
b1110 >
b1110 S
1=
#28
0@
0=
#29
1@
b10000 8
b1111 >
b1111 S
1=
#30
0@
0=
#31
1@
b10001 8
b10000 >
b10000 S
1=
#32
0@
0=
#33
1@
b10010 8
b10001 >
b10001 S
1=
#34
0@
0=
#35
1@
b10011 8
b10010 >
b10010 S
1=
#36
0@
0=
#37
1@
b10100 8
b10011 >
b10011 S
1=
#38
0@
0=
#39
1@
b10101 8
b10100 >
b10100 S
1=
#40
0@
0=
#41
1@
b10110 8
b10101 >
b10101 S
1=
#42
0@
0=
#43
1@
b10111 8
b10110 >
b10110 S
1=
#44
0@
0=
#45
1@
b11000 8
b10111 >
b10111 S
1=
#46
0@
0=
#47
1@
b11001 8
b11000 >
b11000 S
1=
#48
0@
0=
#49
1@
b11010 8
b11001 >
b11001 S
1=
#50
0@
0=
#51
1@
b11011 8
b11010 >
b11010 S
1=
